/*
1. 테이블 정의하기
=> D[i] 를 i번째 집까지 칠했을 떄의 최솟값으로 둔다면 점화식이 세워지지가 않는다.
이웃한 집끼리는 색이 달라야 한다는 규칙이 있는데, 방금 언급한 저 D[i] 의 정의에서는 
그 규칙을 고려하게끔 점화식을 만들 수가 없다.

따라서 테이블을 정의할 떄 색상에 대한 정보가 추가적으로 들어가게끔 해야겠다는 생각이 들고,
아래와 같이 정의를 하면된다.

=> D[i][j] : i번째 집까지 칠할 때 비용의 최솟값, 단 i번쨰 집은 빨강 or 초록 or 파랑 (j=1 일떄 빨강, j=2 일때 초록, j=3 일때 파랑)

D[i][0] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번째 집은 빨강
D[i][1] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번쨰 집은 초록
D[i][2] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번째 집은 파랑


===================================================================================

2. 점화식 찾기 

D[k][0] = min(D[k-1][1], D[k-1][2]) + R[k]    => k번쨰 집을 빨간색으로 칠하는 경우. 즉, k-1 번쨰는 빨간색을 제외한 초록 or 파랑색중 하나를 칠해야한다.
(* R[k] : k번째를 칠할때 드는 비용)
D[k][1] = min(D[k-1][1], D[k-1][2]) + G[k]    => k번째 집을 초록색으로 칠하는 경우. 즉  k-1 번쨰는 초록색을 제외한 빨강 or 파랑색중 하나를 칠한다.
D[k][2] = min(D[k-1][1], D[k-1][2]) + B[k]

====================================================================================

3. 최솟값 찾기

D[1][0] = R[1]
D[1][1] = G[1]
D[1][2] = B[1]
*/

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int n;
int D[1005][3];
int R[1005];
int G[1005];
int B[1005];

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> R[i] >> G[i] >> B[i];
	}

	// 초기값 설정 
	D[1][0] = R[1];
	D[1][1] = G[1];
	D[1][2] = B[1];

	// 2번째 집부터 차례대로 시작해서 n칸까지 칠해가며 테이블을 채운다.
	for (int i = 2; i <= n; i++) {
		D[i][0] = min(D[i - 1][1], D[i - 1][2]) + R[i];  // i번쨰 집을 빨간색으로 칠하는 경우
		D[i][1] = min(D[i - 1][0], D[i - 1][2]) + G[i];  // i번쨰 집을 초록색으로 칠하는 경우
		D[i][2] = min(D[i - 1][0], D[i - 1][1]) + B[i];  // i번쨰 집을 파란색으로 칠하는 경우 
	}

	cout << min( {D[n][0], D[n][1], D[n][2]});  // n번째 집까지 모두 칠했을때의 경우의 수(비용) 중에서 비용의 최솟값
}