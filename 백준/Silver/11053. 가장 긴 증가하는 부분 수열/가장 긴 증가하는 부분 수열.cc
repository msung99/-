/*

탐색 순서는
i = 3일 때 1, 2번째
i = 4일 때 1, 2, 3번째와 비교한다.

입력받는 수를 담을 배열 arr[]와 i번째까지 증가하는 수열 길이를 담을 배열 dp[]를 정의해준다.
d[]의 모든 원소는 1로 초기화해준다. 가장 긴 증가하는 수열이 자기자신 뿐으로 길이가 1일 수도 있다.

i = 3 일때 j = 1, 2
i = 4 일때 j = 1, 2, 3 이라고 하면

arr[i]가 arr[j]보다 작을 경우는 패쓰하고
arr[i]가 arr[j]보다 클 경우에는 d[i] = d[j] + 1을 해준다.

여기서 주의할 점
arr[4]가 arr[2]보다 크고 arr[3]보다 큰데
d[2] = 2, d[3] = 1일 때 d[4]는 2가 되어야 한다.
그러면 매번 d[j]+1값을 비교했을 때 더 큰 값을 선택해주면 된다.
즉, d[i] = max(d[i], d[j]+1)을 반복해주면 된다.

1. 테이블 설정하기
=> d[k] : 1번째부터 시작해서 k번째까지 왔을때 가장 긴 증가하는 수열의 길이

2. 점화식 설정하기
=> d[i] = max(d[i], d[j] + 1)


3. 초기값 설정하기
=> 모든 칸을 1로 초기화
*/

#include <bits/stdc++.h>
using namespace std;

int n;
int arr[1005];
int d[1005];

int main(void)
{
	cin >> n;

	for (int i = 1; i <= n; i++)
		cin >> arr[i];

	for (int i = 1; i <= n; i++)
		d[i] = 1;

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			if (arr[i] > arr[j])  // 증가하는 수열인 경우
				d[i] = max(d[i], d[j] + 1);
		}
	}

	sort(d, d + n + 1);
	cout << d[n];
}


