#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;



// 참고) BFS 풀이법 : dist 배열을 하나 만들어두고, 
// 1을 초기값으로 한뒤 x2, x3, +1 로 뻗어나가면 된다.

/*
DP 활용법
1. 테이블 정의하기 
D[i] = i 를 1로 만들기위해 필요한 연산 사용횟수의 최솟값

2. 점화식 찾기
D[12] 를 구하는 방법 
=> D[1] ~ D[11] 의 값을 모두 알고있다고 해보자.
즉, 1, 2, 3, ..., 11 을 1로 만들기위한 최소 연산횟수를 다 알고있는 경우이다.

이 상황에서	D[12] 를 구할 수 있는 방법은 3가지이다.
1) 3으로 나누거나 (D[12] = D[4] + 1)
2) 2로 나누거나 (D[12] = D[6] + 1)
3) 1을 뺴거나 (D[12] = D[11] + 1)

=> 최종적으로 D[12] = min(D[4] + 1, D[6] + 1, D[11] + 1)
이라는 식을 얻을 수 있다.

* 점화식 정의하기
D[k] 에 대해서 정의해보자.

1) D[k] = D[k/3] + 1   => 3으로 나누어지면 3으로 나누거나
2) D[k] = D[k/2] + 1   => 2로 나누어지면 2로 나누거나
3) D[k] = D[k-1] + 1   => 1을 빼거나
이 중에서 최솟값이 D[k] 의 값이 된다.

=> D[k] = min(D[k/3] + 1, D[k/2] + 1, D[k-1] + 1)

3. 초기값 정의하기

마지막으로 초기값을 생각해보자.
마치 피보나치 수열에서 초항과 2번째 항이 1, 1 인 것처럼
점화식에는 당연히 초기값이 있어야 한다.

이 문제에서는 D[1] = 0 을 초기값으로 주면 나머지는 
점화식을 가지고 값을 계산할 수 있다.

매번 점화식이 돌아갈 수 있게 하기위한 초기값이 어디까지인지를
잘 고민해서 초기값을 정해야하는데, 이 문제에서는 D[1] 에 대해서만 초기값으로 정해주면 된다!
*/

int D[1000001];
 
int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	D[1] = 0;  // 초기값 설정 (사실 배열 D를 전역으로 설정해서 이미 초기값이 0으로 설정되어 있겠지만, 그냥 확실하게 하기위해
	// 0으로 다시 한번 초기화 작업을 굳이해줌) 
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		D[i] = D[i - 1] + 1;
		if (i % 2 == 0)
			D[i] = min(D[i], D[i/2] + 1);
		if (i % 3 == 0)
			D[i] = min(D[i], D[i/3] + 1);
	}
	cout << D[n];
}